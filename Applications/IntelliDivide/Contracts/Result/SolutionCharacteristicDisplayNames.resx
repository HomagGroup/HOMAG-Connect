<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AdditionalCharacteristicsDescription" xml:space="preserve">
    <value>Zusätzlich bietet diese Alternative folgende Besonderheiten:</value>
  </data>
  <data name="BalancedSolution" xml:space="preserve">
    <value>Ausgewogene Produktionszeit &amp; Verschnitt</value>
  </data>
  <data name="BalancedSolutionDescription" xml:space="preserve">
    <value>Ein Kompromiss basierend auf Produktionszeit, Verschnitt und Handling.</value>
  </data>
  <data name="FastestProduction" xml:space="preserve">
    <value>Schnellste Produktion</value>
  </data>
  <data name="FastestProductionDescription" xml:space="preserve">
    <value>Die Alternative bietet die kürzeste Produktionszeit – ideal für eilige Aufträge.</value>
  </data>
  <data name="HighestAutomationLevel" xml:space="preserve">
    <value>Höchster Automatikanteil</value>
  </data>
  <data name="HighestAutomationLevelDescription" xml:space="preserve">
    <value>Die Alternative schneidet die meisten Teile im Automatikbetrieb und reduziert damit manuellen Aufwand. </value>
  </data>
  <data name="HighestNumberOfPlusParts" xml:space="preserve">
    <value>Höchste Anzahl Plusteile</value>
  </data>
  <data name="HighestNumberOfPlusPartsDescription" xml:space="preserve">
    <value>Diese Alternative maximiert die Anzahl produzierter Plusteile und ist geeignet, wenn gezielt Überproduktionen benötigt werden.</value>
  </data>
  <data name="LowestComplexity" xml:space="preserve">
    <value>Einfachste Handhabung</value>
  </data>
  <data name="LowestComplexityDescription" xml:space="preserve">
    <value>Diese Alternative hat im Vergleich besonders einfach zu handhabende Schnittpläne und eignet sich, wenn Bedienerfreundlichkeit im Fokus steht. Der Materialverbrauch oder die Produktionszeit sind eventuell nicht optimal.</value>
  </data>
  <data name="LowestMaterialCosts" xml:space="preserve">
    <value>Niedrigste Materialkosten</value>
  </data>
  <data name="LowestMaterialCostsDescription" xml:space="preserve">
    <value>Die Alternative erzielt die niedrigsten Materialkosten und eignet sich, wenn der Materialverbrauch im Fokus steht. Die Produktionszeit kann höher ausfallen oder die Pläne können komplexer sein.</value>
  </data>
  <data name="LowestNumberOfCycles" xml:space="preserve">
    <value>Geringste Anzahl Zyklen</value>
  </data>
  <data name="LowestNumberOfCyclesDescription" xml:space="preserve">
    <value>Benötigt die wenigsten Bearbeitungszyklen und reduziert Maschinenzeit. Kann zu weniger optimalem Verschnitt oder Handling führen.</value>
  </data>
  <data name="LowestNumberOfPatterns" xml:space="preserve">
    <value>Geringste Anzahl Schnittpläne</value>
  </data>
  <data name="LowestNumberOfPatternsDescription" xml:space="preserve">
    <value>Erzeugt die geringstmögliche Anzahl an Plänen – sorgt für Übersichtlichkeit und Einfachheit.</value>
  </data>
  <data name="LowestOffcutsSmallTotalQuantity" xml:space="preserve">
    <value>Geringste Anzahl kleiner Reste insgesamt</value>
  </data>
  <data name="LowestOffcutsSmallTotalQuantityDescription" xml:space="preserve">
    <value>Die Alternative berücksichtigt vorhandene kleinere Reststücke optimal und reduziert Lagerbestände. Der zusätzliche Handlingsaufwand führt zu einer längeren Produktionszeit.</value>
  </data>
  <data name="LowestOffcutsTotalQuantity" xml:space="preserve">
    <value>Geringste Anzahl Reste insgesamt</value>
  </data>
  <data name="LowestOffcutsTotalQuantityDescription" xml:space="preserve">
    <value>Diese Alternative nutzt vorhandene Reststücke optimal aus – ideal zur Resteverwertung.</value>
  </data>
  <data name="LowestTotalCosts" xml:space="preserve">
    <value>Niedrigste Gesamtkosten</value>
  </data>
  <data name="LowestTotalCostsDescription" xml:space="preserve">
    <value>Die Alternative weist die niedrigsten Gesamtkosten auf und ist daher in typischen Szenarien die empfohlene Lösung.</value>
  </data>
  <data name="LowestWastePercentage" xml:space="preserve">
    <value>Minimaler Abfall</value>
  </data>
  <data name="LowestWastePercentageDescription" xml:space="preserve">
    <value>Reduziert den Abfall auf ein Minimum – ideal zur Materialeinsparung. Es können viele kleinere Reste entstehen, die Lagerplatz benötigen.</value>
  </data>
  <data name="LowestWastePlusOffcutsPercentage" xml:space="preserve">
    <value>Minimaler Abfall incl. Reste</value>
  </data>
  <data name="LowestWastePlusOffcutsPercentageDescription" xml:space="preserve">
    <value>Diese Alternative minimiert den Gesamtabfall inklusive anfallender Reste und ist ideal, wenn Materialeinsparung im Fokus steht.</value>
  </data>
  <data name="LowestWholeBoardsQuantity" xml:space="preserve">
    <value>Geringste Anzahl ganze Platten</value>
  </data>
  <data name="LowestWholeBoardsQuantityDescription" xml:space="preserve">
    <value>Die Alternative benötigt die wenigsten ganzen Platten und spart dadurch Material.</value>
  </data>
  <data name="MaximumAverageBookHeight" xml:space="preserve">
    <value>Maximale durchschnittliche Pakethöhe</value>
  </data>
  <data name="MaximumAverageBookHeightDescription" xml:space="preserve">
    <value>Die Alternative erzielt besonders hohe Pakethöhen und steigert die Effizienz beim Schneiden großer Mengen. Höhere Pakete können schwerer handzuhaben sein.</value>
  </data>
  <data name="None" xml:space="preserve">
    <value>Keine Besonderheiten</value>
  </data>
  <data name="NoneDescription" xml:space="preserve">
    <value>Diese Alternative hat keine Besonderheiten.</value>
  </data>
  <data name="SimilarPatterns" xml:space="preserve">
    <value>Gleichartige Pläne</value>
  </data>
  <data name="SimilarPatternsDescription" xml:space="preserve">
    <value>Diese Alternative hat die meisten gleichen Schnittpläne - sorgt für Übersichtlichkeit und Einfachheit.</value>
  </data>
  <data name="Unknown" xml:space="preserve">
    <value>Unbekannt</value>
  </data>
  <data name="UnknownDescription" xml:space="preserve">
    <value>Unbekannte Charakteristic</value>
  </data>
</root>